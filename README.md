# Веб-приложение для управления задачами с авторизацией пользователей - TaskApp

## Как запустить проект

### Рекомендуемый способ — Docker Compose

# 1) Клонирование репозитория:
```python
git clone https://github.com/Maksim-Borisov7/TaskApp
```

# 2) переходим в папку командой:
```python 
cd TaskApp 
```

# 3) Настройка переменных окружения
+ Создайте файл .env в корне проекта
+ Скопируйте содержимое папки .env.example в .env и подставьте свои данные


# 4) Запуск проекта через Docker
```python 
docker compose up -d --build
```

# 5) После запуска приложение доступно по адресам:
+ backend: http://localhost:8000/docs
+ frontend: http://localhost:5173/

# 6) Остановка контейнера
```python 
docker compose down
```

## Основные возможности

- Регистрация и вход/выход пользователей (JWT-токены)
- Создание, просмотр, удаление и изменение состояния своих задач
- Разделение фронтенда и бэкенда
- Запуск через Docker Compose

## Выполненные требования

**Backend (API)**
+ Получение списка всех задач → `GET /tasks/get/`
+ Создание новой задачи → `POST /tasks/create/`
+ Изменение статуса задачи (выполнена / не выполнена) → `PATCH /tasks/update/{task_id}`
+ Удаление задачи → `DELETE /tasks/delete/{task_id}`


**Frontend**
+ Отображение списка задач
+ Форма создания новой задачи
+ Кнопка для изменения статуса 
+ Кнопка удаления задачи
+ Взаимодействие с API через axios


**Дополнительно реализовано**
- Запуск через Docker Compose (backend + frontend + PostgreSQL)
- Авторизация пользователей + JWT 
- Разделение на backend и frontend
- Базовая обработка ошибок
- Pydantic-схемы и валидация


## Технологии

**Backend**
- Python 3.13
- FastAPI
- SQLAlchemy 
- PostgreSQL
- PyJWT 
- Uvicorn

**Frontend**
- JavaScript + React + Vite + Ant Design + Axios  
- Axios для запросов к бэкенду


## Вот основные архитектурные решения, которые я принял в проекте TaskApp и причины, почему именно так:
# 1. Разделение backend и frontend (отдельные папки / модули)
### Решение:
Проект строго разделён на две независимые части: backend/ и frontend/.
### Почему: 

+ Монолитное приложение проще проверять. Все приложение лежит в одном месте.
+ Упрощает тестирование, деплой и масштабирование в будущем.
+ Позволяет разрабатывать/дебагить frontend и backend независимо.

# 2. JWT-авторизация 
### Решение
Добавлена авторизация через JWT-токены (access-токен), пользователи регистрируются/логинятся, каждая задача привязана к user_id.
### Почему: 

+ В ТЗ авторизация была опциональной → реализация как плюс даёт преимущество.
+ Намного безопаснее 
+ Решает проблему «пользователь видит только свои задачи» — более реалистично, чем общий список для всех.
+ JWT — простой и популярный способ в API

# 3. Docker + Docker Compose для запуска
### Решение
Один docker-compose.yml поднимает backend + postgres + frontend.
### Почему

+ Самый простой и надёжный способ дать ревьюеру «запустил одной командой».
+ Гарантирует одинаковое окружение.
+ Показывает навыки контейнеризации.


# 4. Использование Clean Architecture
### Почему
+ Чёткое разделение ответственности.
+ Легко тестировать.
+ Соответствует большинству гайдов по FastAPI → многим будет знакомо и понятно.